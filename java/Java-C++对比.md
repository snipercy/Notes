## Java 与 C++ 不完全对比
### 概况
Foo a; 			// c++ 声明 a 为一个对象值，调用缺省构造函数，c++11： Foo a{args};
a = new Foo();  // java 先声明 a 为一个Foo类对象的引用

Foo b = a; 			// c++ 调用拷贝构造函数,等价于Foo b(a)
Foo b = a; 			// java 浅拷贝，b 只是引用了 a
Foo b = a.clone();  // java 深拷贝，会创建新的对象,前提是 Foo 实现了

cou << b.x << endl;
System.out.println(b.x);

Foo *c; // c++ 指针未定义，可能指向任何地方
Foo c;  // java c 为一个 Foo 对象的引用（initially null if c is a class member; 
		// it is necessary to initialize c before use
		// if it is a local variable）

c->x = 5;
c.x = 5;

Foo *const b = new Foo();  // c++
final Foo b = new Foo();   // java

### Java 具有如下特性

- 基本数据类型为**值类型**，数组、枚举、类、接口均为**引用**类型
- 没有**全局**变量、全局函数、没有struct，没有union，所有东西都必须写入类中
- 用**包**代替了命名空间，用 import 关键字来导入包进行使用
- 所有对象都从 Object 类单根继承，支持接口继承
- Java 没有预处理过程（不存在宏）、没有goto、没有指针、没有析构函数、不支持函数缺省参数，不支持运算符重载

### Java 基本类型及其包装类

- boolean 1字节		Boolean
- char    2字节		Character
- byte 	  1字节		Byte
- short	  2字节		Short
- int     4字节		Integer
- long    8字节		Long
- float	  4字节		Float
- double  8字节		Double

基本类型的大小固定，与平台无关，因此 Java 并没有提供c++中sizeof运算符

### 右移位运算符 `>>>`

`>>`  : 逻辑右移， 移位的同时插入符号位
`>>>` : 左端末尾插入零值

```java
int n1 = -1;		// n1 = 0xFFFFFFFF
int n2 = n1 >> 1;   // n2 = 0xFFFFFFFF
int n3 = n1 >>> 1;  // n3 = 0x7FFFFFFF
```

### 函数参数传递

Java 函数中没有指针传递、引用传递，只有值传递。

**值类型**参数会产生一个值类型副本，**引用类型**参数会产生一个引用类型副本，即对象的地址l

### 字符串

String 处理不变的字符串，任何对 String 的改变都会引发**新的 String** 对象的生成

- String： 不可改变
- StringBuffer： 可变字符串序列，内存中保存的痛String一样，都是有序char数组，不同的是 StringBuffer 对象的值都是可变的。
- StringBuilder： 与 StringBuffer 区别是线程安全

```java
String s1 = "hello";			// 静态创建字符串
String s2 = new String("你好"); // 动态创建字符串
```


判断相等：

	s1 == s2;					// s1 与 s2 是否指向同一个对象
	s1.equals(s5);				// 内容是否完全一致
	s1.equalsIgnoreCase(s2);	// 忽略大小写比较

String 类的”=“、”+“、”+=“，看似运算符重载，实际只是Java编译器做了一点手脚，对String运算符做了特殊处理。

```java
String s = "hello ";
s += "world";		 // 编译器转换成：s = (new StringBuilder()).append(s).append("world").toString();
```

`StringBuffer`  处理可变字符串（线程安全），不可被继承（final）
`StringBuilder` 处理可变字符串（线程不安全，拥有更高的性能），不可被继承（final），JDK1.5引入


### 重写（Override）与重载（Overload）

重写：上下级之间
重载：同一个类中

重写：返回值和形参都不能改变。即外壳不变，核心重写！重写的好处在于子类可以根据需要，定义特定于自己的行为。

#### 方法的重写规则
- 参数、返回类型必须完全相同；
- 访问权限不能比父类中被重写的方法的访问权限更高。例如：如果父类的一个方法被声明为public，那么在子类中重写该方法就不能声明为protected。
- 父类的成员方法只能被它的子类重写。
- 声明为final的方法不能被重写。
- 声明为static的方法不能被重写，但是能够被再次声明。
- 子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为private和final的方法。
- 子类和父类不在同一个包中，那么子类只能够重写父类的声明为public和protected的非final方法。
- 重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。
- 构造方法不能被重写。
- 如果不能继承一个方法，则不能重写这个方法。


#### 重载规则

一个类中，方法名字相同，而参数不同，返回类型可以相同可以不同。

- 被重载的方法必须改变参数列表；
- 被重载的方法可以改变返回类型；
- 被重载的方法可以改变访问修饰符；
- 被重载的方法可以声明新的或更广的检查异常；
- 方法能够在同一个类中或者在一个子类中被重载。




### Java 异常

- 检查性异常：最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。例如要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略。
- 运行时异常： 运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。
- 错误： 错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了，它们在编译也检查不到的。


### Java 接口

#### 接口与类相似点：
- 一个接口可以有多个方法。
- 接口文件保存在.java结尾的文件中，文件名使用接口名。
- 接口的字节码文件保存在.class结尾的文件中。
- 接口相应的字节码文件必须在与包名称相匹配的目录结构中。 

#### 接口与类的区别：
- 接口不能用于实例化对象。
- 接口没有构造方法。
- 接口中所有的方法必须是抽象方法。
- 接口不能包含成员变量，除了static和final变量。
- 接口不是被类继承了，而是要被类实现。
- 接口支持多重继承。

#### 接口有以下特性：
- 接口是隐式抽象的，当声明一个接口的时候，不必使用abstract关键字。
- 接口中每一个方法也是隐式抽象的，声明时同样不需要abstract关键子。
- 接口中的方法都是公有的。

``` java
interface Animal {

   public void eat();
   public void travel();
}
```
``` public class MammalInt implements Animal{...} ```

#### 重写接口中声明的方法时，需要注意以下规则：
- 类在实现接口的方法时，不能抛出强制性异常，只能在接口中，或者继承接口的抽象类中抛出该强制性异常。
- 类在重写方法时要保持一致的方法名，并且应该保持相同或者相兼容的返回值类型。
- 如果实现接口的类是抽象类，那么就没必要实现该接口的方法。

#### 在实现接口的时候，也要注意一些规则：
- 一个类可以同时实现多个接口。
- 一个类只能继承一个类，但是能实现多个接口。
- 一个接口能继承另一个接口，这和类之间的继承比较相似。























