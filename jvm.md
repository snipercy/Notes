jvm 类加载机制有5个步骤：加载，验证，准备，解析，初始化。

## 加载
会在内存中生产该类的 Class 对象,

当一个ClassLoader实例需要加载某个类时，它会试图亲自搜索某个类之前，先把这个任务委托给它的父类加载器，这个过程是由上至下依次检查的，首先由最顶层的类加载器Bootstrap ClassLoader试图加载，如果没加载到，则把任务转交给Extension ClassLoader试图加载，如果也没加载到，则转交给App ClassLoader 进行加载，如果它也没有加载得到的话，则返回给委托的发起者，由它到指定的文件系统或网络等URL中加载该类。如果它们都没有加载到这个类时，则抛出ClassNotFoundException异常。否则将这个找到的类生成一个类的定义，并将它加载到内存当中，最后返回这个类在内存中的Class实例对象。

JVM在判定两个class是否相同时，不仅要判断两个类名是否相同，而且要判断是否由同一个类加载器实例加载的。只有两者同时满足的情况下，JVM才认为这两个class是相同的。

因为Java中提供的默认ClassLoader，只加载指定目录下的jar和class，如果我们想加载其它位置的类或jar时，比如：我要加载网络上的一个class文件，通过动态加载到内存之后，要调用这个类中的方法实现我的业务逻辑。在这样的情况下，默认的ClassLoader就不能满足我们的需求了，所以需要定义自己的ClassLoader。

- 类加载器虽然只用于实现类的加在动作，但是它在 Java 程序中起到的作用却远远不限于类加载阶段。


(通过自定义加载器加载的对象使用instanceof关键字做对象所属关系判定时都为false。)

- 对于任意一个类，都需要由加载它的类加载器和这个类本身确定其在 Java 虚拟机中的唯一性。这就解释了为什么上面判断时为出现 false，因为一个使用的系统提供的类加载器，而另一个是使用了自己编写的加载器。




## 验证
验证 Class 文件中的字节流中无包含的信息是否符合虚拟机要求，不会危害虚拟机安全。


## 准备
为类变量分配内存并初始化，方法区中
public static int v = 8080;
准备阶段过后值还是为0，赋值8080是被编译后，构造器clent方法之中

public static final int v = 8080;
在编译阶段会为v生成 ConstantValue 属性，在准备阶段虚拟机会根据ConstantValue属性将v赋值为8080。
